#!/bin/bash

set -euo pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOT_HOME="$(dirname "$SCRIPT_DIR")"

# Source utilities
source "$DOT_HOME/lib/colors.sh"
source "$DOT_HOME/lib/constants.sh"
source "$DOT_HOME/lib/utils.sh"
source "$DOT_HOME/lib/logging.sh"

# Show usage
usage() {
    local installed_system="unknown"
    if is_system_installed; then
        installed_system=$(head -n1 "$INSTALLATION_MARKER")
    fi

    cat << EOF
dot - Dotfiles management tool for $installed_system

USAGE:
    dot [COMMAND] [ARGS...]
    INSTALLATION=SYSTEM dot [COMMAND] [ARGS...]

COMMANDS:
    install [MODULE]    Install packages and applications
                        Modules: all (default)

    build [MODULE]      Build and deploy configuration files
                        Modules: all (default)

    upgrade [MODULE]    Upgrade source-built packages
                        Modules: all (default)

    pull                Update dotfiles repository from git
    sync                Pull latest changes and rebuild all
    pwd                 Print dotfiles directory path
    doctor              Check system health and requirements
    help                Show this help message

EXAMPLES:
    dot                             # Show this help message
    dot install                     # Install all packages
    dot install <package>           # Install specific package
    dot install --list              # List available packages for install
    dot build <path/package>        # Build specific package
    dot build --list                # List available packages for build
    dot upgrade                     # Upgrade all source-built packages
    dot upgrade package             # Upgrade specific source-built packages
    dot upgrade --list              # List available packages for upgrade
    dot pull                        # Update dotfiles repository
    dot sync                        # Pull and rebuild everything
    dot pwd                         # Print dotfiles directory path
    
    # Override system without installation marker:
    INSTALLATION=debian dot install      # Install debian packages
    INSTALLATION=debian dot build        # Build debian configs

EOF
}

# Check if system is set up
check_system_setup() {
    # Allow override via environment variable
    if [[ -n "$INSTALLATION" ]]; then
        return 0
    fi
    
    if ! is_system_installed; then
        log_error "System not initialized. Please run one of the install scripts at bin/install-* first"
        exit 1
    fi
}

# Get system directory path
get_system_dir() {
    # Use environment variable override if provided
    if [[ -n "$INSTALLATION" ]]; then
        echo "$DOT_HOME/$INSTALLATION"
        return 0
    fi
    
    local installed_system=$(head -n1 "$INSTALLATION_MARKER")
    echo "$DOT_HOME/$installed_system"
}

# Resolve module name (handles numeric prefixes like 00-, 01-)
resolve_module_path() {
    local module="$1"
    local system_dir="$(get_system_dir)"
    
    # First, try the module as-is
    if [[ -d "$system_dir/$module" ]]; then
        echo "$module"
        return 0
    fi
    
    # If module contains /, handle each part
    if [[ "$module" == */* ]]; then
        local parent="${module%/*}"
        local child="${module##*/}"
        
        # Try with numeric prefix on child
        for prefix in {00..99}; do
            if [[ -d "$system_dir/$parent/${prefix}-${child}" ]]; then
                echo "$parent/${prefix}-${child}"
                return 0
            fi
        done
        
        # Try with numeric prefix on parent
        for prefix in {00..99}; do
            if [[ -d "$system_dir/${prefix}-${parent}/$child" ]]; then
                echo "${prefix}-${parent}/$child"
                return 0
            fi
        done
    else
        # Try with numeric prefixes for top-level modules
        for prefix in {00..99}; do
            if [[ -d "$system_dir/${prefix}-${module}" ]]; then
                echo "${prefix}-${module}"
                return 0
            fi
        done
    fi
    
    # Return original if no match found
    echo "$module"
    return 1
}

# Check system setup for --list operations
check_system_for_list() {
    # Allow override via environment variable
    if [[ -n "$INSTALLATION" ]]; then
        return 0
    fi
    
    if ! is_system_installed; then
        log_error "System not initialized. Please run one of the install scripts at bin/install-* first"
        exit 1
    fi
}

# Get available modules for a given command
get_available_modules() {
    local command="$1"
    local modules=()
    
    # Get the installed system type
    local installed_system
    if [[ -n "$INSTALLATION" ]]; then
        installed_system="$INSTALLATION"
    else
        installed_system=$(head -n1 "$INSTALLATION_MARKER")
    fi
    local system_dir="$DOT_HOME/$installed_system"
    
    # Check if system directory exists
    if [[ ! -d "$system_dir" ]]; then
        return
    fi
    
    # Find all modules with the given command script
    while IFS= read -r -d '' script; do
        local module_path=$(dirname "$script")
        # Get the full relative path from system_dir
        local module_name="${module_path#$system_dir/}"
        
        modules+=("$module_name")
    done < <(find "$system_dir" -name "$command" -type f -executable -print0)
    
    printf '%s\n' "${modules[@]}" | sort
}

# Run install command
cmd_install() {
    local module="${1:-all}"
    
    # Handle --list option
    if [[ "$module" == "--list" ]]; then
        check_system_for_list
        echo "Available modules for install:"
        get_available_modules "install"
        return 0
    fi
    
    check_system_setup
    init_logging "install"
    
    log_header "Installing: $module"
    
    if [[ "$module" == "all" ]]; then
        log_info "Installing all modules"
        
        # Get all available install scripts
        local available_modules
        mapfile -t available_modules < <(get_available_modules "install")
        
        for mod in "${available_modules[@]}"; do
            log_step "Running install for module: $mod"
            "$(get_system_dir)/$mod/install"
        done
    else
        # Install specific module
        local resolved_module=$(resolve_module_path "$module")
        if [[ -x "$(get_system_dir)/$resolved_module/install" ]]; then
            "$(get_system_dir)/$resolved_module/install"
        else
            log_error "Module $module does not have an install script"
            exit 1
        fi
    fi
    
    finalize_logging "success"
}

# Run build command
cmd_build() {
    local module="${1:-all}"
    
    # Handle --list option
    if [[ "$module" == "--list" ]]; then
        check_system_for_list
        echo "Available modules for build:"
        get_available_modules "build"
        return 0
    fi
    
    check_system_setup
    init_logging "build"
    
    log_header "Building: $module"
    
    if [[ "$module" == "all" ]]; then
        log_info "Building all modules"
        
        # Get all available build scripts
        local available_modules
        mapfile -t available_modules < <(get_available_modules "build")
        
        for mod in "${available_modules[@]}"; do
            log_step "Running build for module: $mod"
            "$(get_system_dir)/$mod/build"
        done
    else
        # Build specific module
        local resolved_module=$(resolve_module_path "$module")
        if [[ -x "$(get_system_dir)/$resolved_module/build" ]]; then
            "$(get_system_dir)/$resolved_module/build"
        else
            log_error "Module $module does not have a build script"
            exit 1
        fi
    fi
    
    finalize_logging "success"
}

# Run upgrade command
cmd_upgrade() {
    local module="${1:-all}"
    
    # Handle --list option
    if [[ "$module" == "--list" ]]; then
        check_system_for_list
        echo "Available modules for upgrade:"
        get_available_modules "upgrade"
        return 0
    fi
    
    check_system_setup
    init_logging "upgrade"
    
    log_header "Upgrading: $module"
    
    if [[ "$module" == "all" ]]; then
        log_info "Upgrading all modules"
        
        # Get all available upgrade scripts
        local available_modules
        mapfile -t available_modules < <(get_available_modules "upgrade")
        
        if [[ ${#available_modules[@]} -eq 0 ]]; then
            log_info "No modules have upgrade scripts"
            finalize_logging "success"
            return
        fi
        
        for mod in "${available_modules[@]}"; do
            log_step "Running upgrade for module: $mod"
            "$(get_system_dir)/$mod/upgrade"
        done
    else
        # Upgrade specific module
        local resolved_module=$(resolve_module_path "$module")
        if [[ -x "$(get_system_dir)/$resolved_module/upgrade" ]]; then
            "$(get_system_dir)/$resolved_module/upgrade"
        else
            log_error "Module $module does not have an upgrade script"
            exit 1
        fi
    fi
    
    finalize_logging "success"
}

# Sync command - pull and build
cmd_sync() {
    # First pull
    cmd_pull
    
    # Then build all
    cmd_build "all"
}

# Pull command - update dotfiles repository
cmd_pull() {
    init_logging "pull"
    
    log_header "Updating dotfiles repository"
    
    # Save current directory
    local current_dir="$(pwd)"
    
    # Change to dotfiles directory
    cd "$DOT_HOME"
    
    # Get current branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    log_info "Current branch: $current_branch"
    
    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        log_warning "You have uncommitted changes:"
        git status --short
        log_error "Please commit or stash your changes before pulling"
        cd "$current_dir"
        finalize_logging "failed"
        exit 1
    fi
    
    # Pull latest changes
    log_step "Pulling latest changes from $current_branch"
    if git pull origin "$current_branch"; then
        log_success "Repository updated successfully"
        
        # Show what changed
        local changes=$(git log --oneline HEAD@{1}..HEAD 2>/dev/null)
        if [[ -n "$changes" ]]; then
            log_info "Recent changes:"
            echo "$changes"
        else
            log_info "Already up to date"
        fi
    else
        log_error "Failed to pull changes"
        cd "$current_dir"
        finalize_logging "failed"
        exit 1
    fi
    
    # Return to original directory
    cd "$current_dir"
    
    finalize_logging "success"
}

# Doctor command - check system health
cmd_doctor() {
    init_logging "doctor"
    
    log_header "System Doctor"
    
    local issues=0
    
    # Check basic system
    if ! is_system_installed; then
        log_error "System not initialized. Run an install script first (bin/install-*)"
        ((issues++))
    else
        local installed_system=$(get_installed_system)
        log_success "System is initialized: $installed_system"
        
        # Check if the system directory exists
        local system_dir="$DOT_HOME/$installed_system"
        if [[ ! -d "$system_dir" ]]; then
            log_error "System directory not found: $system_dir"
            ((issues++))
        else
            log_success "System directory exists: $system_dir"
        fi
    fi
    
    
    # Check required directories
    if [[ ! -d "$LOG_DIR" ]]; then
        log_warning "Log directory missing: $LOG_DIR"
        ((issues++))
    else
        log_success "Log directory exists"
    fi
    
    # Check flatpak setup (if available)
    if command_exists flatpak; then
        if ! flatpak remote-list --system 2>/dev/null | grep -q flathub; then
            log_warning "Flathub repository not configured (install apps may fail)"
            ((issues++))
        else
            log_success "Flathub repository configured"
        fi
    else
        log_info "Flatpak not available on this system"
    fi
    
    # Run OS-specific checks if available
    if is_system_installed; then
        local installed_system=$(get_installed_system)
        local system_doctor="$DOT_HOME/$installed_system/doctor"
        
        if [[ -x "$system_doctor" ]]; then
            log_step "Running $installed_system-specific checks"
            if "$system_doctor" >/dev/null 2>&1; then
                log_success "OS-specific checks passed"
            else
                local os_issues=$?
                log_warning "OS-specific checks found $os_issues issue(s)"
                ((issues += os_issues))
            fi
        fi
    fi
    
    # Summary
    echo
    if [[ $issues -eq 0 ]]; then
        log_success "No issues found!"
    else
        log_warning "Found $issues issue(s)"
    fi
    
    finalize_logging "success"
}

# Main command dispatcher
main() {
    # Don't run as root
    if is_root; then
        log_error "Don't run dot as root/sudo. It will ask for sudo when needed."
        exit 1
    fi
    
    if [[ $# -eq 0 ]]; then
        usage
        return
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        install)
            cmd_install "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        pull)
            cmd_pull
            ;;
        sync)
            cmd_sync
            ;;
        pwd)
            echo "$DOT_HOME"
            ;;
        doctor)
            cmd_doctor
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
