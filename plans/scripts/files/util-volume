#!/bin/bash

# Author: Viktor Habchak <vikdotdev@gmail.com>
#
# Description:
# This script is intended to act as pactl wrapper, that is capable
# of setting upper volume boundary for the default sink.

getdefaultsinkname() {
  pactl info | awk -F": " '/^Default Sink: /{print $2}'
}

getdefaultsinkvol() {
  pactl list sinks |
    awk '/^\s+Name: /{indefault = $2 == "'$(getdefaultsinkname)'"}
         /^\s+Volume: / && indefault {print $5; exit}'
}

setdefaulsinkvol() {
  pactl set-sink-volume $(getdefaultsinkname) $1
}

SIGN=$(echo "$1" | head -c 1)
VALUE=$(echo $1 | head -c 5 | cut -d '+' -f2 | cut -d '%' -f1)
UPPERBOUND=150

VOLUME=$(getdefaultsinkvol)
NEW_VOLUME=$(echo "${VOLUME%?}" + "$VALUE" | bc)

if [ "$SIGN" = '+' ]; then
  if [ "$NEW_VOLUME" -lt "$UPPERBOUND" ]; then
    setdefaulsinkvol $1
  else
    puts "Config does not exist."
    exit(1)
  end
rescue Errno::ENOENT => e
  puts "Error reading file"
  puts e.message
  exit(1)
rescue JSON::ParserError => e
  puts "Error parsing file"
  puts e.message
  exit(1)
end

def current_sink_info = @current_sink_info ||= JSON.parse(`pactl -f json info`)
def current_sink_name = current_sink_info.fetch("default_sink_name")
def current_sink = sink_list.find { _1["name"] == current_sink_name }
def sink_list = @sink_list ||= JSON.parse(`pactl -f json list sinks`)
def set_current_sink_volume!(value) = system("pactl set-sink-volume #{current_sink_name} #{value}%")

def current_sink_volume
  volume = current_sink.fetch("volume")
  front_left_volume = volume.fetch("front-left").fetch("value")
  front_right_volume = volume.fetch("front-right").fetch("value")

  (front_left_volume + front_right_volume) / 2
rescue KeyError => e
  puts "Failed to fetch current volume level"
  puts e.backtrace.take(5)
  exit(1)
end

def relative_int_to_percent(value) = value.to_f / BASE_VOL_INT * 100
def bounded_percent(value) = [value, sink_volume_boundary(current_sink_name)].min

parser = OptionParser.new do |opts|
  opts.banner = <<~DESC
    Volume management script. Example usage:

    util-volume -d 5 # increases volume by 5%
    util-volume -i 5 # increases volume by 5%
    util-volume      # prints current volume level
  DESC

  opts.on('-iVALUE', '--inc=VALUE', 'Increase volume by percentage value') do |value|
    relative_int_to_percent(current_sink_volume)
      .then { bounded_percent(_1 + value.to_i) }
      .then { set_current_sink_volume!(_1) }
  end

  opts.on('-dVALUE', '--dec=VALUE', 'Decrease volume by percentage value') do |value|
    relative_int_to_percent(current_sink_volume)
      .then { (new_value = _1 - value.to_i) <= 0 ? 0 : new_value }
      .then { bounded_percent(_1) }
      .then { set_current_sink_volume!(_1) }
  end

  opts.on('-bVALUE', '--set-boundary=VALUE', "Set current sink boundary") do |value|
    value = value.to_i
    if value.positive?
      set_sink_volume_boundary!(value)

      relative_int_to_percent(current_sink_volume)
        .then { value < _1 ? value : _1 }
        .then { bounded_percent(_1) }
        .then { set_current_sink_volume!(_1) }
    else
      puts "Value cannot be negative"
    end
  end

  opts.on('-p', '--print', 'Print current percentage volume value') do
    puts "Current volume: #{relative_int_to_percent(current_sink_volume).round.to_i}"
  end

  opts.on_tail('--help', 'Print help') do
    puts opts
    exit
  end
end

parser.parse('--help') if ARGV.empty?

config # initialize config
parser.parse!

